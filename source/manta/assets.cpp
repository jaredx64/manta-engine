#include <manta/assets.hpp>

#include <core/string.hpp>

#include <manta/filesystem.hpp>

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

namespace Assets
{
	char binaryPath[PATH_SIZE];
	File binary;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool CoreAssets::init()
{
	// Binary Path
	strjoin( Assets::binaryPath, WORKING_DIRECTORY, SLASH BUILD_PROJECT, ".bin" );

	// Open Binary
	Assets::binary.open( Assets::binaryPath );
	PrintLn( "%s", Assets::binaryPath );
	ErrorReturnIf( !Assets::binary, false, "Assets: Failed to open binary file: %s", Assets::binaryPath );

	// Success
	return true;
}


bool CoreAssets::free()
{
	// Close Binary File
	Assets::binary.close();

	// Success
	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

const Assets::DataAssetEntry &Assets::data_asset( DataAsset asset )
{
	Assert( asset < CoreAssets::dataAssetCount );
	return CoreAssets::dataAssets[asset];
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

const Assets::TextureEntry &Assets::texture( Texture texture )
{
	Assert( texture < CoreAssets::textureCount );
	return CoreAssets::textures[texture];
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

const Assets::GlyphEntry &Assets::glyph( const u32 glyph )
{
	Assert( glyph < CoreAssets::glyphCount );
	return CoreAssets::glyphs[glyph];
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

const Assets::SpriteEntry &Assets::sprite( Sprite sprite )
{
	Assert( sprite < CoreAssets::spriteCount );
	return CoreAssets::sprites[sprite];
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

const Assets::MaterialEntry &Assets::material( Material material )
{
	Assert( material < CoreAssets::materialCount );
	return CoreAssets::materials[material];
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

const Assets::TTFEntry &Assets::ttf( const u32 ttf )
{
	Assert( ttf < CoreAssets::ttfCount );
	return CoreAssets::ttfs[ttf];
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

const Assets::FontEntry &Assets::font( const u32 font )
{
	Assert( font < CoreAssets::fontCount );
	return CoreAssets::fonts[font];
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

const Assets::SoundEntry &Assets::sound( Sound sound )
{
	Assert( sound < CoreAssets::soundCount );
	return CoreAssets::sounds[sound];
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

const Assets::Skeleton2DEntry &Assets::skeleton_2d( Skeleton skeleton2D )
{
	Assert( skeleton2D < CoreAssets::skeleton2DCount );
	return CoreAssets::skeleton2Ds[skeleton2D];
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#if 0
const Assets::Skeleton3DEntry &Assets::skeleton_3d( Skeleton3D skeleton3 )
{
	Assert( skeleton3D < CoreAssets::skeleton3DCount );
	return CoreAssets::skeleton3Ds[skeleton3D];
};
#endif

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////