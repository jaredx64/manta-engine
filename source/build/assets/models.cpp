#include <build/assets/models.hpp>

#include <core/types.hpp>
#include <core/debug.hpp>
#include <core/list.hpp>
#include <core/json.hpp>
#include <core/checksum.hpp>

#include <build/build.hpp>
#include <build/assets.hpp>

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

struct CacheModel
{
	usize meshCount;
	u32 meshCacheIDs[MODEL_MESH_COUNT_MAX];
	usize textureCount;
	u32 textureCacheIDs[MODEL_MESH_COUNT_MAX];
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

struct VertexPosition { float x, y, z; };
struct VertexNormal { float x, y, z; };
struct VertexTexcoord { float u, v, w; };

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ModelID Models::allocate_new( const Model &model )
{
	AssertMsg( models.size() < MESHID_MAX, "Exceeded max number of Models" );
	models.add( model );
	return static_cast<ModelID>( models.size() - 1 );
}


ModelID Models::allocate_new( Model &&model )
{
	AssertMsg( models.size() < GLYPHID_MAX, "Exceeded max number of Models" );
	models.add( static_cast<Model &&>( model ) );
	return static_cast<ModelID>( models.size() - 1 );
}


usize Models::gather( const char *path, bool recurse )
{
	//return 0LLU; // TODO: Temporarily disabled until module is completed

	static const char *fileExtensions[MODELFILETYPE_COUNT] =
	{
		".model", // ModelFileType_BINARY
		".obj", // ModelFileType_OBJ
	};

	// Gather & Load Models
	List<FileInfo> files;
	usize modelCount = 0LLU;
	for( ModelFileType type = 0; type < MODELFILETYPE_COUNT; type++ )
	{
		files.clear();
		directory_iterate( files, path, fileExtensions[type], recurse );
		for( FileInfo &fileInfo : files )
		{
			// NOTE: Files generated by the linker in output/ can have the extension .obj -- need to skip these
			if( strcontains_case_insensitive( fileInfo.path, "output" ) ) { continue; }

			modelCount++;
			Assets::cacheFileCount++;
			process( fileInfo.path, type );
		}
	}
	return modelCount;
}


void Models::process( const char *path, ModelFileType type )
{
	// Local Directory
	static char pathDirectory[PATH_SIZE];
	path_get_directory( pathDirectory, sizeof( pathDirectory ), path );

	// Register Model File
	AssetFile file;
	if( !asset_file_register( file, path ) )
	{
		Error( "Model '%s' - unable to locate and open model file", file.name );
		return;
	}

	// Cache ID
	static char cacheIDBuffer[PATH_SIZE * 3];
	memory_set( cacheIDBuffer, 0, sizeof( cacheIDBuffer ) );
	snprintf( cacheIDBuffer, sizeof( cacheIDBuffer ), "model %s|%llu",
		file.path, file.time.as_u64() );
	const CacheID cacheID = checksum_xcrc32( cacheIDBuffer, sizeof( cacheIDBuffer ), 0 );

	// Load
	switch( type )
	{
		case ModelFileType_BINARY:
			ErrorIf( !load_binary( file, cacheID ), "Model: failed to load .model: %s", file.path );
		break;

		case ModelFileType_OBJ:
			ErrorIf( !load_obj( file, cacheID ), "Model: failed to load .obj: %s", file.path );
		break;

		default: AssertMsg( true, "Model: Unexpected ModelFileType '%u' (%s)", type, file.name ); break;
	}

	// Store Cache
	CacheModel cache;
	const Model &model = models[models.count() - 1];
	cache.meshCount = model.meshes.count();
	for( usize i = 0; i < cache.meshCount; i++ )
	{
		cache.meshCacheIDs[i] = Assets::meshes[model.meshes[i]].cacheID;
	}
	/*
	cache.textureCount = model.textures.count();
	for( usize i = 0; i < cache.textureCount; i++ )
	{
		cache.textureCacheIDs[i] = Assets::textures[model.textures[i]].;
	}
	*/
	Assets::cache.store( cacheID, cache );
}



void Models::build()
{
	Buffer &binary = Assets::binary;
	String &header = Assets::header;
	String &source = Assets::source;
	const u32 count = static_cast<u32>( models.size() );

	Timer timer;

	// Header
	{
		// Group
		assets_group( header );

		// Enums
		header.append( "enum_class\n(\n\tModel, u32,\n\n" );
		for( Model &model : models ) { header.append( "\t" ).append( model.name ).append( ",\n" ); }
		header.append( "\n\tNull = 0,\n" );
		header.append( ");\n\n" );

		// Struct
		header.append( "namespace Assets { struct ModelEntry; }\n\n" );

		// Entries
		header.append( "namespace CoreAssets\n{\n" );
		header.append( "\tconstexpr u32 modelCount = " ).append( count ).append( ";\n" );
		header.append( count > 0 ? "\textern const Assets::ModelEntry models[modelCount];\n" :
			"\textern const Assets::ModelEntry *models;\n" );
		header.append( "}\n\n" );
	}

	// Source
	{
		// Group
		assets_group( source );
		source.append( "namespace CoreAssets\n{\n" );
		if( count > 0 )
		{
			// Assets::ModelEntry Table
			char buffer[PATH_SIZE];
			source.append( "\tconst Assets::ModelEntry models[modelCount] =\n\t{\n" );
			for( Model &model : models )
			{
				source.append( "\t\t// " ).append( model.name ).append( "\n" );
				source.append( "\t\t{\n" );

				Assert( model.meshes.count() == model.textures.count() );
				const u32 meshCount = model.meshes.count();
				source.append( "\t\t\t" ).append( meshCount ).append( ",\n" );

				source.append( "\t\t\t{ " );
				for( u32 i = 0; i < MODEL_MESH_COUNT_MAX; i++ )
				{
					source.append( i < model.meshes.count() ? model.meshes[i] : 0 );
					source.append( i < MODEL_MESH_COUNT_MAX - 1 ? ", " : " " );
				}
				source.append( "},\n" );

				source.append( "\t\t\t{ " );
				for( u32 i = 0; i < MODEL_MESH_COUNT_MAX; i++ )
				{
					source.append( i < model.textures.count() ? model.textures[i] : 0 );
					source.append( i < MODEL_MESH_COUNT_MAX - 1 ? ", " : " " );
				}
				source.append( "},\n" );

				snprintf( buffer, sizeof( buffer ), "%ff, %ff, %ff, %ff, %ff, %ff",
					model.x1,
					model.y1,
					model.z1,
					model.x2,
					model.y2,
					model.z2 );
				source.append( "\t\t\t" ).append( buffer ).append("\n");

				source.append( "\t\t},\n" );
			}
			source.append( "\t};\n" );
		}
		else
		{
			source.append( "\tconst Assets::ModelEntry *models = nullptr;\n" );
		}
		source.append( "}\n\n" );
	}

	if( verbose_output() )
	{
		const usize count = models.size();
		Print( PrintColor_White, TAB TAB "Wrote %d model%s", count, count == 1 ? "" : "es" );
		PrintLn( PrintColor_White, " (%.3f ms)", timer.elapsed_ms() );
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Models::load_from_cache( CacheID cacheID )
{
	CacheModel cache;
	if( !Assets::cache.fetch( cacheID, cache ) ) { Assets::cache.dirty |= true; return false; }

	// ...

	return true;
}


bool Models::load_binary( const AssetFile &file, CacheID cacheID )
{
	// ...

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static bool is_number( const char c )
{
	return ( c >= '0' && c <= '9' ) || c == '+' || c == '-' || c == '.';
}


static usize next_number( const String &file, usize &tell )
{
	// Early out
	if( file[tell] == '\n' || file[tell] == '\0' )
	{
		return USIZE_MAX;
	}

	// Seek to beginning of a number
	usize start = tell;
	while( !is_number( file[start] ) )
	{
		if( file[start] == '\n' || file[start] == '\0' )
		{
			tell = start;
			return USIZE_MAX;
		}

		start++;
	}

	// Seek to end of number
	usize end = start;
	while( is_number( file[end] ) ) { end++; }
	tell = end;

	// Return number position
	return start == end ? USIZE_MAX : start;
}


static bool next_float( const String &file, usize &tell, float &out )
{
	// Seek to beginning of a number
	usize index = next_number( file, tell );
	if( index == USIZE_MAX) { out = 0.0f; return false; }

	// Read float
	out = static_cast<float>( atof( file.get_pointer( index ) ) );
	return true;
}


static bool next_u32( const String &file, usize &tell, u32 &out )
{
	// Seek to beginning of a number
	usize index = next_number( file, tell );
	if( index == USIZE_MAX) { out = 0; return false; }

	// Read float
	out = static_cast<u32>( atoi( file.get_pointer( index ) ) );
	return true;
}


static usize next_key( const String &file, usize &tell, const char *key )
{
	tell = file.find( key, tell );
	if( tell == USIZE_MAX ) { return tell; }
	tell += strlen( key );
	return tell;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

struct VertexTuple
{
	u32 positionIndex;
	u32 texcoordIndex;
	u32 normalIndex;
};


static bool obj_next_vertex_position( const String &file, usize &tell, List<VertexPosition> &positions )
{
	tell = next_key( file, tell, "v " );
	if( tell == USIZE_MAX ) { return false; }

	VertexPosition &vertex = positions.add( VertexPosition { } );
	next_float( file, tell, vertex.x );
	next_float( file, tell, vertex.y );
	next_float( file, tell, vertex.z );
	return true;
};


static bool obj_next_vertex_normal( const String &file, usize &tell, List<VertexNormal> &normals )
{
	tell = next_key( file, tell, "vn " );
	if( tell == USIZE_MAX ) { return false; }

	VertexNormal &normal = normals.add( VertexNormal { } );
	next_float( file, tell, normal.x );
	next_float( file, tell, normal.y );
	next_float( file, tell, normal.z );
	return true;
};


static bool obj_next_vertex_texcoord( const String &file, usize &tell, List<VertexTexcoord> &texcoords )
{
	tell = next_key( file, tell, "vt " );
	if( tell == USIZE_MAX ) { return false; }

	VertexTexcoord &uv = texcoords.add( VertexTexcoord { } );
	next_float( file, tell, uv.u );
	next_float( file, tell, uv.v );
	// next_float( file, tell, uv.w ); TODO: Is this ever even used?
	return true;
};


static bool obj_next_face( const String &file, usize &tell,
	const List<VertexPosition> &positions,
	const List<VertexTexcoord> &textureCoords,
	const List<VertexNormal> &normals,
	HashMap<u32, u32> &faces,
	List<VertexTuple> &vertices,
	List<u32> &indices )
{
	tell = next_key( file, tell, "f " );
	if( tell == USIZE_MAX ) { return false; }

	// TODO: Support quads as well
	for( int i = 0; i < 3; i++ )
	{
		VertexTuple tuple;
		next_u32( file, tell, tuple.positionIndex );
		next_u32( file, tell, tuple.texcoordIndex );
		next_u32( file, tell, tuple.normalIndex );
		const u32 key = Hash::hash_from( tuple );

		if( faces.contains( key ) )
		{
			const u32 index = faces.get( key );
			indices.add( index );
		}
		else
		{
			const u32 index = vertices.count();
			vertices.add( tuple );
			indices.add( index );
			faces.add( key, index );
		}
	}

	return true;
}


static void obj_parse_vertex_positions( const String &file, List<VertexPosition> &positions )
{
	usize tell = 0LLU;
	while( obj_next_vertex_position( file, tell, positions ) ) { }
}


static void obj_parse_vertex_texcoords( const String &file, List<VertexTexcoord> &texcoords )
{
	usize tell = 0LLU;
	while( obj_next_vertex_texcoord( file, tell, texcoords ) ) { }
}


static void obj_parse_vertex_normals( const String &file, List<VertexNormal> &normals )
{
	usize tell = 0LLU;
	while( obj_next_vertex_normal( file, tell, normals ) ) { }
}


static void obj_parse_faces( const String &file,
	const List<VertexPosition> &positions,
	const List<VertexTexcoord> &texcoords,
	const List<VertexNormal> &normals,
	HashMap<u32, u32> &faces, List<VertexTuple> &vertices, List<u32> &indices )
{
	usize tell = 0LLU;
	while( obj_next_face( file, tell, positions, texcoords, normals, faces, vertices, indices ) ) { }
}


bool Models::load_obj( const AssetFile &file, CacheID cacheID )
{
	//CacheModel cache;
	//if( !Assets::cache.fetch( cacheID, cache ) ) { Assets::cache.dirty |= true; return false; }

	// Load Model File
	String obj;
	if( !obj.load( file.path ) ) { return false; }

	// Allocate Model
	const ModelID modelID = Assets::models.allocate_new( Model { } );
	Model &model = Models::models[models.count() - 1];
	model.path = file.path;
	model.name = file.name;
	model.x1 = FLOAT_MAX;
	model.y1 = FLOAT_MAX;
	model.z1 = FLOAT_MAX;
	model.x2 = FLOAT_MIN;
	model.y2 = FLOAT_MIN;
	model.z2 = FLOAT_MIN;

	// Parse Data
	static List<VertexPosition> positions;
	static List<VertexTexcoord> texcoords;
	static List<VertexNormal> normals;
	positions.clear();
	texcoords.clear();
	normals.clear();
	obj_parse_vertex_positions( obj, positions );
	obj_parse_vertex_normals( obj, normals );
	obj_parse_vertex_texcoords( obj, texcoords );

	// Parse Faces
	static HashMap<u32, u32> faces;
	static List<VertexTuple> vertices;
	static List<u32> indices;
	faces.clear();
	vertices.clear();
	indices.clear();

	obj_parse_faces( obj, positions, texcoords, normals, faces, vertices, indices );

	// Build VBO
	struct GfxVertex
	{
		float x, y, z;
		float nx, ny, nz;
		u16 u, v;
	};

	float x1 = FLOAT_MAX;
	float y1 = FLOAT_MAX;
	float z1 = FLOAT_MAX;
	float x2 = FLOAT_MIN;
	float y2 = FLOAT_MIN;
	float z2 = FLOAT_MIN;

	Buffer vertexBuffer;
	for( usize i = 0; i < vertices.count(); i++ )
	{
		const VertexTuple &vertex = vertices[i];
		const VertexPosition &position = positions[vertex.positionIndex - 1];
		const VertexNormal &normal = normals[vertex.normalIndex - 1];
		const VertexTexcoord &texcoord = texcoords[vertex.texcoordIndex - 1];

		x1 = min( position.x, x1 );
		model.x1 = min( x1, model.x1 );
		y1 = min( position.y, y1 );
		model.y1 = min( y1, model.y1 );
		z1 = min( position.z, z1 );
		model.z1 = min( z1, model.z1 );
		x2 = max( position.x, x2 );
		model.x2 = max( x2, model.x2 );
		y2 = max( position.y, y2 );
		model.y2 = max( y2, model.y2 );
		z2 = max( position.z, z2 );
		model.z2 = max( z2, model.z2 );

		GfxVertex out = GfxVertex { };
		out.x = position.x;
		out.y = position.y;
		out.z = position.z;
		out.nx = normal.x;
		out.ny = normal.y;
		out.nz = normal.z;
		out.u = static_cast<u16>( texcoord.u * 0xFFFF );
		out.v = static_cast<u16>( ( 1.0f - texcoord.v ) * 0xFFFF );
		vertexBuffer.write( out );
	}

	static char meshName[PATH_SIZE];
	snprintf( meshName, sizeof( meshName ), "%s_%u", model.name.cstr(), 0U ); // TODO
	CacheID meshCacheID = Hash::hash_from( cacheID, 0U ); // TODO

	PrintLn( "%s: %llu | %llu", model.name.cstr(), vertexBuffer.size() / sizeof( GfxVertex ), indices.count() );

	MeshID meshID = Assets::meshes.allocate_new( meshName, meshCacheID,
		MeshFormatTypeVertex_Default, vertexBuffer.data, vertexBuffer.size(),
		MeshFormatTypeIndex_U32, indices.data, indices.count() * sizeof( u32 ),
		x1, y1, z1, x2, y2, z2 );

	model.meshes.add( meshID );
	model.textures.add( 0U ); // TODO

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////