#include <build/assets.hpp>

#include <build/build.hpp>

#include <core/string.hpp>

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

struct CacheAssets { usize fileCount = 0LLU; };

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

namespace Assets
{
	// Output Paths
	char pathHeader[PATH_SIZE];
	char pathSource[PATH_SIZE];

	// Output contents
	String source;
	String header;
	Buffer binary;

	// Asset Types
	DataAssets dataAssets;
	Textures textures;
	Glyphs glyphs;
	Sprites sprites;
	Materials materials;
	Fonts fonts;
	Sounds sounds;
	Skeleton2Ds skeleton2Ds;

	// Cache
	Cache cache;
	usize cacheReadOffset = 0LLU;
	usize cacheFileCount = 0LLU;

	// Logging
	usize assetsBuilt = 0LLU;
	usize assetsCached = 0LLU;
}


void Assets::begin()
{
	// Paths
	strjoin( pathHeader, Build::pathOutput, SLASH "generated" SLASH "assets.generated.hpp" );
	strjoin( pathSource, Build::pathOutput, SLASH "generated" SLASH "assets.generated.cpp" );
}


void Assets::end()
{
	// ...
}


void Assets::codegen()
{
	// Header (assets.generated.hpp)
	{
		if( verbose_output() )
		{
			PrintColor( LOG_WHITE, TAB TAB "Write " );
			PrintColor( LOG_CYAN, "%s", Assets::pathHeader );
		}
		Timer timer;

		// Begin header
		String header;
		header.append( "#pragma once\n\n" );
		header.append( COMMENT_BREAK "\n\n" );
		header.append( "/*\n" );
		header.append( " * File generated by build.exe\n" );
		header.append( " * Refer to: source/build/build.cpp (BuilderCore::assets_write)\n" );
		header.append( " */\n" );
		header.append( COMMENT_BREAK "\n\n" );
		header.append( "#include <binary.generated.hpp>\n\n" );
		header.append( "#include <core/types.hpp>\n" );
		header.append( "#include <core/debug.hpp>\n\n" );

		// Append header
		Assets::header.append( COMMENT_BREAK "\n\n" );
		header.append( Assets::header );

		// Save header
		ErrorIf( !header.save( Assets::pathHeader ), "Failed to write '%s'", Assets::pathHeader );

		if( verbose_output() )
		{
			PrintLnColor( LOG_WHITE, " (%.3f ms)", timer.elapsed_ms() );
		}
	}

	// Source (assets.generated.cpp)
	{
		if( verbose_output() )
		{
			PrintColor( LOG_WHITE, TAB TAB "Write " );
			PrintColor( LOG_CYAN, "%s", Assets::pathSource );
		}
		Timer timer;

		// Begin source
		String source;

		source.append( COMMENT_BREAK "\n\n" );
		source.append( "/*\n" );
		source.append( " * File generated by build.exe\n" );
		source.append( " * Refer to: source/build/build.cpp (BuilderCore::assets_write)\n" );
		source.append( " */\n\n" );
		source.append( COMMENT_BREAK "\n\n" );
		source.append( "#include <manta/assets.hpp>\n" );
		source.append( "#include <manta/fonts.hpp>\n\n" );
		source.append( "#include <binary.generated.hpp>\n" );
		source.append( "#include <assets.generated.hpp>\n\n" );

		// Append source
		Assets::source.append( COMMENT_BREAK "\n\n" );
		source.append( Assets::source );

		// Save source
		ErrorIf( !source.save( Assets::pathSource ), "Failed to write '%s'", Assets::pathSource );

		if( verbose_output() )
		{
			PrintLnColor( LOG_WHITE, " (%.3f ms)", timer.elapsed_ms() );
		}
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool asset_file_register( AssetFile &asset, const char *path )
{
	// File Time
	if( !file_time( path, &asset.time ) ) { asset.exists = false; return false; }

	// Store path
	snprintf( asset.path, sizeof( asset.path ), "%s", path );

	// Extract file name (no extension)
	char name[PATH_SIZE];
	path_get_filename( name, sizeof( name ), path );
	path_remove_extensions( name, sizeof( name ) );
	snprintf( asset.name, sizeof( asset.name ), "%s", name );

	asset.exists = true;
	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Assets::cache_read( const char *path )
{
	Assets::cache.dirty |= Build::cache.dirty;

	// Assets Cache
	if( !Assets::cache.dirty )
	{
		Assets::cache.read( path );
		Assets::cache.dirty |= Assets::cache.dirty;
	}

	// Codegen Cache
	AssetFile codegen;
	if( !asset_file_register( codegen, pathHeader ) ) { Assets::cache.dirty = true; return; }
	if( !asset_file_register( codegen, pathSource ) ) { Assets::cache.dirty = true; return; }
}


void Assets::cache_write( const char *path )
{
	if( !Assets::cache.dirty ) { return; }
	cache.write( path );
}


void Assets::cache_validate()
{
	// Validate file count
	CacheAssets cacheAssets;
	if( !Assets::cache.fetch( 0, cacheAssets ) ) { Assets::cache.dirty |= true; }
	Assets::cache.dirty |= ( Assets::cacheFileCount != cacheAssets.fileCount );

	// Cache file count
	cacheAssets.fileCount = Assets::cacheFileCount;
	Assets::cache.store( 0, cacheAssets );
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Assets::log_asset_cache( const char *type, const char *name )
{
	assetsCached++;
	if( !verbose_output() ) { return; }
	PrintLnColor( LOG_MAGENTA, TAB TAB "%s '%s' cached", type, name );
}


void Assets::log_asset_build( const char *type, const char *name )
{
	assetsBuilt++;
	if( !verbose_output() ) { return; }
	PrintLnColor( LOG_RED, TAB TAB "%s '%s' built", type, name );
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////